package com.mulesoft.arc.arcdatastore.backend;

import com.google.appengine.api.datastore.Cursor;
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.FetchOptions;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.PreparedQuery;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.QueryResultList;
import com.google.appengine.api.memcache.ErrorHandlers;
import com.google.appengine.api.memcache.Expiration;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import com.google.apphosting.api.ApiProxy;
import com.mulesoft.arc.arcdatastore.backend.models.UsersComputationResult;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * A class that is responsible for making a query to the users analytics data in low-level API.
 *
 * It uses cursors and loops to get data. I'm hoping that it will make it possible to finally fetch
 * the data from the datastore even in the task queue.
 */

class AnalyticsUserQuery {
    private static final Logger log = Logger.getLogger(AnalyticsUserQuery.class.getName());
    /**
     * When making a query limited by the QUERY_SIZE the result function will set
     * queryCursor to the query cursor generated by the datastore to fetch more results.
     */
    private Cursor cursor = null;
    /**
     * List of uuids fetched from the datastore.
     */
    private ArrayList<String> uids = new ArrayList<>();
    /**
     * Number of computed users
     */
    private Integer users = 0;

    private DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

    private final Long fromDate;
    private final Long toDate;

    AnalyticsUserQuery(Long fromDate, Long toDate) {
        this.fromDate = fromDate;
        this.toDate = toDate;
    }

    private void reset() {
        users = 0;
        cursor = null;
        uids = new ArrayList<>();
    }

    UsersComputationResult query() throws IllegalArgumentException {
        reset();
        try {
            restoreCache();
        } catch (Exception e) {
            reset();
        }

//        log.info("About to query data for " + fromDate + " - " + toDate);

        boolean hasMore;
        long requiredMililis = 10000; // 10 seconds?
        do {
            long mls = ApiProxy.getCurrentEnvironment().getRemainingMillis();
            if (requiredMililis > mls) {
                // nearly execution timeout.
                // Generally the DeadlineExceededException handler by the servlet will do the same
                // But it's better to have more time to handle cache save.
                saveCache();
                return null;
            }
            hasMore = makeQuery();
        } while(hasMore);

        UsersComputationResult result = new UsersComputationResult();
        result.users = users;
        result.startDate = new Date(fromDate);
        result.endDate = new Date(toDate);
        return result;
    }

    private boolean makeQuery() throws IllegalArgumentException {
        int QUERY_SIZE = 5000;

        FetchOptions fetchOptions = FetchOptions.Builder.withLimit(QUERY_SIZE);

        if (cursor != null) {
            fetchOptions.startCursor(cursor);
        }

        Query.Filter fromTimeFilter = new Query.FilterPredicate("day", Query.FilterOperator.GREATER_THAN_OR_EQUAL, fromDate);
        Query.Filter toTimeFilter = new Query.FilterPredicate("day", Query.FilterOperator.LESS_THAN_OR_EQUAL, toDate);
        Query.Filter timeRangeFilterFilter = Query.CompositeFilterOperator.and(fromTimeFilter, toTimeFilter);

        Query q = new Query("User")
                .setFilter(timeRangeFilterFilter)
                .setKeysOnly();

        PreparedQuery pq = datastore.prepare(q);
        QueryResultList<Entity> results = pq.asQueryResultList(fetchOptions);

        int cnt = 0;
        for (Entity item: results) {
            Key key = item.getKey();
            String keyValue = key.getName();
            String[] parts = keyValue.split("/");
            if (parts.length != 2) {
                log.warning("The key for daily users is invalid: " + keyValue);
                continue;
            }
            String appId = parts[0];
            if (!uids.contains(appId)) {
                uids.add(appId);
                users++;
            }
            cnt++;
        }

        if (cnt < QUERY_SIZE) {
            return false;
        }

        cursor = results.getCursor();

        return true;
    }

    /**
     * When the request timeout for the task, try to cache results to restore them when
     * re-executing the query.
     *
     * This function to be called by the caller class when the query throws an exception.
     */
    private void saveCache() {
        if (users == 0) {
            // no data.
            return;
        }

        MemcacheService syncCache = MemcacheServiceFactory.getMemcacheService();
        syncCache.setErrorHandler(ErrorHandlers.getConsistentLogAndContinue(Level.INFO));

        String keyPrefix = getCacheKey();
        Map<String, java.io.Serializable> properties = new HashMap<>();
        properties.put(getUuidsCacheKey(keyPrefix), uids);
        properties.put(getUsersCacheKey(keyPrefix), users);
        properties.put(getCursorCacheKey(keyPrefix), cursor.toWebSafeString());

        // Tasks are re-run every 1 hour so will set 2 hrs just to be sure.
        syncCache.putAll(properties, Expiration.byDeltaSeconds(2 *60 * 60));
    }

    @SuppressWarnings("unchecked")
    private void restoreCache() {
        MemcacheService syncCache = MemcacheServiceFactory.getMemcacheService();
        syncCache.setErrorHandler(ErrorHandlers.getConsistentLogAndContinue(Level.INFO));
        String keyPrefix = getCacheKey();
        ArrayList<String> _uuid;
        try {
            _uuid = (ArrayList<String>) syncCache.get(getUuidsCacheKey(keyPrefix));
        } catch (ClassCastException e) {
            log.info("Rebuilding query from cache: _uuid is not ArrayList.");
            return;
        }
        Integer _users = (Integer) syncCache.get(getUsersCacheKey(keyPrefix));
        String _cursorString = (String) syncCache.get(getCursorCacheKey(keyPrefix));
        if (_uuid == null && _users == null && _cursorString == null) {
            log.info("Rebuilding query from cache: no cache data available.");
            return;
        }
        clearCache(syncCache, keyPrefix);
        if (_uuid == null || _users == null || _cursorString == null) {
            log.warning("Rebuilding query from cache: some data were available, skipping.");
            return;
        }

        uids = _uuid;
        users = _users;
        cursor = Cursor.fromWebSafeString(_cursorString);
    }

    private void clearCache(MemcacheService syncCache, String keyPrefix) {
        syncCache.delete(getUuidsCacheKey(keyPrefix));
        syncCache.delete(getUsersCacheKey(keyPrefix));
        syncCache.delete(getCursorCacheKey(keyPrefix));
    }

    private String getCacheKey() {
        return "users-" + fromDate + "-" + toDate;
    }

    private String getUuidsCacheKey(String prefix) {
        return prefix + ".uuids";
    }
    private String getUsersCacheKey(String prefix) {
        return prefix + ".users";
    }
    private String getCursorCacheKey(String prefix) {
        return prefix + ".cursor";
    }
}
