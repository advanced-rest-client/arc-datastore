package com.mulesoft.arc.arcdatastore.backend;

import com.google.appengine.api.datastore.Cursor;
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.FetchOptions;
import com.google.appengine.api.datastore.PreparedQuery;
import com.google.appengine.api.datastore.PropertyProjection;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.QueryResultList;
import com.google.appengine.api.memcache.ErrorHandlers;
import com.google.appengine.api.memcache.Expiration;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import com.mulesoft.arc.arcdatastore.backend.models.QueryResult;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * A class that is responsible for making a query to the Analytics data in low-level API.
 *
 * It uses cursors and loops to get data. I'm hoping that it will make it possible to finally fetch
 * the data from the datastore even in the task queue.
 */

class AnalyticsQuery {
    private static final Logger log = Logger.getLogger(AnalyticsQuery.class.getName());
    /**
     * When making a query limited by the QUERY_SIZE the result function will set
     * queryCursor to the query cursor generated by the datastore to fetch more results.
     */
    private Cursor cursor = null;
    /**
     * List of uuids fetched from the datastore.
     */
    private ArrayList<String> uids = new ArrayList<>();
    /**
     * Number of computed users
     */
    private long users = 0;
    /**
     * Number of computed sessions
     */
    private long sessions = 0;

    private DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

    private final Date fromDate;
    private final Date toDate;

    AnalyticsQuery(Date fromDate, Date toDate) {
        this.fromDate = fromDate;
        this.toDate = toDate;
    }

    private void reset() {
        users = 0;
        sessions = 0;
        cursor = null;
        uids = new ArrayList<>();
    }

    QueryResult query() throws IllegalArgumentException {
        reset();
        try {
            restoreCache();
        } catch (Exception e) {
            reset();
        }

        log.info("About to query data for " + fromDate.toString() + " - " + toDate.toString());

        boolean hasMore;
        do {
            hasMore = makeQuery();
            log.info("Query returned with flag: " + hasMore);
        } while(hasMore);

        QueryResult result = new QueryResult();
        result.sessions = sessions;
        result.users = users;
        result.startDate = fromDate;
        result.endDate = toDate;
        return result;
    }

    private boolean makeQuery() throws IllegalArgumentException {
        int QUERY_SIZE = 5000;
        FetchOptions fetchOptions = FetchOptions.Builder.withLimit(QUERY_SIZE);
        if (cursor != null) {
            log.info("Setting up cursor from previous query.");
            fetchOptions.startCursor(cursor);
        } else {
            log.info("No cursor available. Querying from the beginning.");
        }
        Query.Filter downFilter = new Query.FilterPredicate("date", Query.FilterOperator.GREATER_THAN_OR_EQUAL, fromDate);
        Query.Filter upFilter = new Query.FilterPredicate("date", Query.FilterOperator.LESS_THAN_OR_EQUAL, toDate);
        Query.Filter queryFilter = Query.CompositeFilterOperator.and(downFilter, upFilter);

        Query q = new Query("ArcSession")
                .setFilter(queryFilter)
                .addProjection(new PropertyProjection("appId", String.class));

        PreparedQuery pq = datastore.prepare(q);
        QueryResultList<Entity> results = pq.asQueryResultList(fetchOptions);

        int cnt = 0;
        for (Entity item: results) {
            String appId = (String) item.getProperty("appId");
            if (!uids.contains(appId)) {
                uids.add(appId);
                users++;
            }
            sessions++;
            cnt++;
        }

        if (cnt < QUERY_SIZE) {
            log.info("Fetched entities is less than page size. No more records.");
            return false;
        }
        log.info("Setting cursor for the next query.");
        cursor = results.getCursor();
        return true;
    }

    /**
     * When the request timeout for the task, try to cache results to restore them when
     * re-executing the query.
     *
     * This function to be called by the caller class when the query throws an exception.
     */
    void saveCache() {
        if (sessions == 0 || fromDate == null || toDate == null) {
            // no data.
            return;
        }

        MemcacheService syncCache = MemcacheServiceFactory.getMemcacheService();
        syncCache.setErrorHandler(ErrorHandlers.getConsistentLogAndContinue(Level.INFO));

        String keyPrefix = getCacheKey();
        Map<String, java.io.Serializable> properties = new HashMap<String, java.io.Serializable>();
        properties.put(getUuidsCacheKey(keyPrefix), uids);
        properties.put(getSessionsCacheKey(keyPrefix), sessions);
        properties.put(getUsersCacheKey(keyPrefix), users);
        properties.put(getCursorCacheKey(keyPrefix), cursor.toWebSafeString());

        // Tasks are re-run every 1 hour so will set 2 hrs just to be sure.
        syncCache.putAll(properties, Expiration.byDeltaSeconds(2 *60 * 60));
    }

    private void restoreCache() {
        if (fromDate == null || toDate == null) {
            // not ready.
            return;
        }
        MemcacheService syncCache = MemcacheServiceFactory.getMemcacheService();
        syncCache.setErrorHandler(ErrorHandlers.getConsistentLogAndContinue(Level.INFO));
        String keyPrefix = getCacheKey();
        ArrayList<String> _uuid = (ArrayList<String>) syncCache.get(getUuidsCacheKey(keyPrefix));
        Long _sessions = (Long) syncCache.get(getSessionsCacheKey(keyPrefix));
        Long _users = (Long) syncCache.get(getUsersCacheKey(keyPrefix));
        String _cursorString = (String) syncCache.get(getCursorCacheKey(keyPrefix));
        if (_uuid == null && _sessions == null && _users == null && _cursorString == null) {
            log.info("Rebuilding query from cache: no cache data available.");
            return;
        }
        clearCache(syncCache, keyPrefix);
        if (_uuid == null || _sessions == null || _users == null || _cursorString == null) {
            log.warning("Rebuilding query from cache: some data were available, skipping.");
            return;
        }

        uids = _uuid;
        sessions = _sessions;
        users = _users;
        cursor = Cursor.fromWebSafeString(_cursorString);
    }

    private void clearCache(MemcacheService syncCache, String keyPrefix) {
        syncCache.delete(getUuidsCacheKey(keyPrefix));
        syncCache.delete(getSessionsCacheKey(keyPrefix));
        syncCache.delete(getUsersCacheKey(keyPrefix));
        syncCache.delete(getCursorCacheKey(keyPrefix));
    }

    private String getCacheKey() {
        return fromDate.getTime() + "-" + toDate.getTime();
    }

    private String getUuidsCacheKey(String prefix) {
        return prefix + ".uuids";
    }
    private String getSessionsCacheKey(String prefix) {
        return prefix + ".sessions";
    }
    private String getUsersCacheKey(String prefix) {
        return prefix + ".users";
    }
    private String getCursorCacheKey(String prefix) {
        return prefix + ".cursor";
    }
}
