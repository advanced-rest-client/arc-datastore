package com.mulesoft.arc.arcdatastore.backend;

import com.google.appengine.api.datastore.Cursor;
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.FetchOptions;
import com.google.appengine.api.datastore.PreparedQuery;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.QueryResultList;
import com.google.appengine.api.memcache.ErrorHandlers;
import com.google.appengine.api.memcache.Expiration;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;
import com.google.apphosting.api.ApiProxy;
import com.mulesoft.arc.arcdatastore.backend.models.SessionsComputationResult;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * A class that is responsible for making a query to the analytics data in low-level API.
 *
 * It uses cursors and loops to get data. I'm hoping that it will make it possible to finally fetch
 * the data from the datastore even in the task queue.
 */

class AnalyticsSessionsQuery {
    private static final Logger log = Logger.getLogger(AnalyticsSessionsQuery.class.getName());
    /**
     * When making a query limited by the QUERY_SIZE the result function will set
     * queryCursor to the query cursor generated by the datastore to fetch more results.
     */
    private Cursor cursor = null;
    /**
     * Number of computed sessions
     */
    private int sessions = 0;

    private DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

    private final Long fromDate;
    private final Long toDate;

    AnalyticsSessionsQuery(long fromDate, long toDate) {
        this.fromDate = fromDate;
        this.toDate = toDate;
    }

    private void reset() {
        sessions = 0;
        cursor = null;
    }

    SessionsComputationResult query() throws IllegalArgumentException {
        reset();
        try {
            restoreCache();
        } catch (Exception e) {
            reset();
        }

//        log.info("About to query data for " + fromDate.toString() + " - " + toDate.toString());

        boolean hasMore;
        long requiredMililis = 10000; // 10 seconds?
        do {
            long mls = ApiProxy.getCurrentEnvironment().getRemainingMillis();
            if (requiredMililis > mls) {
                // nearly execution timeout.
                // Generally the DeadlineExceededException handler by the servlet will do the same
                // But it's better to have more time to handle cache save.
                saveCache();
                return null;
            }
            hasMore = makeQuery();
        } while(hasMore);

        SessionsComputationResult result = new SessionsComputationResult();
        result.sessions = sessions;
        result.startDate = new Date(fromDate);
        result.endDate = new Date(toDate);
        return result;
    }

    private boolean makeQuery() throws IllegalArgumentException {
        int QUERY_SIZE = 5000;

        FetchOptions fetchOptions = FetchOptions.Builder.withLimit(QUERY_SIZE);

        if (cursor != null) {
            fetchOptions.startCursor(cursor);
        }

        Query.Filter fromTimeFilter = new Query.FilterPredicate("day", Query.FilterOperator.GREATER_THAN_OR_EQUAL, fromDate);
        Query.Filter toTimeFilter = new Query.FilterPredicate("day", Query.FilterOperator.LESS_THAN_OR_EQUAL, toDate);
        Query.Filter timeRangeFilterFilter = Query.CompositeFilterOperator.and(fromTimeFilter, toTimeFilter);

        Query q = new Query("Session")
                .setFilter(timeRangeFilterFilter)
                .setKeysOnly();

        PreparedQuery pq = datastore.prepare(q);
        QueryResultList<Entity> results = pq.asQueryResultList(fetchOptions);

        int receivedSize = results.size();
        sessions += receivedSize;

        if (receivedSize < QUERY_SIZE) {
            return false;
        }

        cursor = results.getCursor();
        return true;
    }

    /**
     * When the request timeout for the task, try to cache results to restore them when
     * re-executing the query.
     *
     * This function to be called by the caller class when the query throws an exception.
     */
    private void saveCache() {
        if (sessions == 0) {
            // no data.
            return;
        }

        MemcacheService syncCache = MemcacheServiceFactory.getMemcacheService();
        syncCache.setErrorHandler(ErrorHandlers.getConsistentLogAndContinue(Level.INFO));

        String keyPrefix = getCacheKey();
        Map<String, java.io.Serializable> properties = new HashMap<>();
        properties.put(getSessionsCacheKey(keyPrefix), sessions);
        properties.put(getCursorCacheKey(keyPrefix), cursor.toWebSafeString());

        // Tasks are re-run every 1 hour so will set 2 hrs just to be sure.
        syncCache.putAll(properties, Expiration.byDeltaSeconds(2 *60 * 60));
    }

    private void restoreCache() {
        MemcacheService syncCache = MemcacheServiceFactory.getMemcacheService();
        syncCache.setErrorHandler(ErrorHandlers.getConsistentLogAndContinue(Level.INFO));
        String keyPrefix = getCacheKey();
        Integer _sessions = (Integer) syncCache.get(getSessionsCacheKey(keyPrefix));
        String _cursorString = (String) syncCache.get(getCursorCacheKey(keyPrefix));
        if (_sessions == null && _cursorString == null) {
            log.info("Rebuilding query from cache: no cache data available.");
            return;
        }
        clearCache(syncCache, keyPrefix);
        if (_sessions == null || _cursorString == null) {
            log.warning("Rebuilding query from cache: some data were available, skipping.");
            return;
        }
        sessions = _sessions;
        cursor = Cursor.fromWebSafeString(_cursorString);
    }

    private void clearCache(MemcacheService syncCache, String keyPrefix) {
        syncCache.delete(getSessionsCacheKey(keyPrefix));
        syncCache.delete(getCursorCacheKey(keyPrefix));
    }

    private String getCacheKey() {
        return "sessions-" + fromDate + "-" + toDate;
    }

    private String getSessionsCacheKey(String prefix) {
        return prefix + ".sessions";
    }
    private String getCursorCacheKey(String prefix) {
        return prefix + ".cursor";
    }
}
